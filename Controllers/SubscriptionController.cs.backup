using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using CRM.Attributes;
using CRM.Models;
using CRM.Services;
using System.Text.Json;

namespace CRM.Controllers
{
    [RoleAuthorize("Admin", "Partner")]
    public class SubscriptionController : Controller
    {
        private readonly AppDbContext _context;
        private readonly SubscriptionService _subscriptionService;
        private readonly RazorpayService _razorpayService;
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly ILogger<SubscriptionController> _logger;

        public SubscriptionController(
            AppDbContext context, 
            SubscriptionService subscriptionService,
            RazorpayService razorpayService,
            IHttpContextAccessor httpContextAccessor,
            ILogger<SubscriptionController> logger)
        {
            _context = context;
            _subscriptionService = subscriptionService;
            _razorpayService = razorpayService;
            _httpContextAccessor = httpContextAccessor;
            _logger = logger;
        }

        private (int? UserId, string? Role, int? ChannelPartnerId) GetCurrentUserContext()
        {
            var token = _httpContextAccessor.HttpContext?.Request.Cookies["jwtToken"];
            if (string.IsNullOrEmpty(token)) return (null, null, null);
            
            var jwt = new System.IdentityModel.Tokens.Jwt.JwtSecurityTokenHandler().ReadJwtToken(token);
            var userIdClaim = jwt.Claims.FirstOrDefault(c => c.Type == "UserId")?.Value;
            var role = jwt.Claims.FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Role)?.Value;
            
            if (!int.TryParse(userIdClaim, out int userId)) return (null, role, null);
            
            var user = _context.Users.FirstOrDefault(u => u.UserId == userId);
            return (userId, role, user?.ChannelPartnerId);
        }

        // Subscription Plans Management (Admin)
        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> Plans()
        {
            var plans = await _context.SubscriptionPlans
                .OrderBy(p => p.SortOrder)
                .ThenBy(p => p.MonthlyPrice)
                .ToListAsync();
            
            return View(plans);
        }

        // Get Plans for API/AJAX calls
        [HttpGet]
        public async Task<IActionResult> GetPlans()
        {
            var plans = await _context.SubscriptionPlans
                .Where(p => p.IsActive)
                .OrderBy(p => p.SortOrder)
                .ThenBy(p => p.MonthlyPrice)
                .Select(p => new
                {
                    planId = p.PlanId,
                    planName = p.PlanName,
                    monthlyPrice = p.MonthlyPrice,
                    yearlyPrice = p.YearlyPrice,
                    maxAgents = p.MaxAgents,
                    maxLeadsPerMonth = p.MaxLeadsPerMonth,
                    maxStorageGB = p.MaxStorageGB
                })
                .ToListAsync();
            
            return Json(plans);
        }

        [HttpGet]
        [RoleAuthorize("Admin")]
        public IActionResult CreatePlan()
        {
            return View(new SubscriptionPlanModel());
        }

        [HttpPost]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> CreatePlan(SubscriptionPlanModel model)
        {
            if (ModelState.IsValid)
            {
                model.CreatedDate = DateTime.Now;
                _context.SubscriptionPlans.Add(model);
                await _context.SaveChangesAsync();

                if (Request.Headers["X-Requested-With"] == "XMLHttpRequest")
                    return Json(new { success = true, message = "Plan created successfully!" });

                return RedirectToAction(nameof(Plans));
            }

            if (Request.Headers["X-Requested-With"] == "XMLHttpRequest")
                return Json(new { success = false, errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });

            return View(model);
        }

        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> EditPlan(int id)
        {
            var plan = await _context.SubscriptionPlans.FindAsync(id);
            if (plan == null) return NotFound();
            
            return View(plan);
        }

        [HttpPost]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> UpdatePlan(SubscriptionPlanModel model)
        {
            if (ModelState.IsValid)
            {
                var existingPlan = await _context.SubscriptionPlans.FindAsync(model.PlanId);
                if (existingPlan == null) return NotFound();

                existingPlan.PlanName = model.PlanName;
                existingPlan.Description = model.Description;
                existingPlan.MonthlyPrice = model.MonthlyPrice;
                existingPlan.YearlyPrice = model.YearlyPrice;
                existingPlan.MaxAgents = model.MaxAgents;
                existingPlan.MaxLeadsPerMonth = model.MaxLeadsPerMonth;
                existingPlan.MaxStorageGB = model.MaxStorageGB;
                existingPlan.HasWhatsAppIntegration = model.HasWhatsAppIntegration;
                existingPlan.HasFacebookIntegration = model.HasFacebookIntegration;
                existingPlan.HasEmailIntegration = model.HasEmailIntegration;
                existingPlan.HasCustomAPIAccess = model.HasCustomAPIAccess;
                existingPlan.HasAdvancedReports = model.HasAdvancedReports;
                existingPlan.HasCustomReports = model.HasCustomReports;
                existingPlan.HasDataExport = model.HasDataExport;
                existingPlan.HasPrioritySupport = model.HasPrioritySupport;
                existingPlan.HasPhoneSupport = model.HasPhoneSupport;
                existingPlan.HasDedicatedManager = model.HasDedicatedManager;
                existingPlan.SupportLevel = model.SupportLevel;
                existingPlan.IsActive = model.IsActive;
                existingPlan.PlanType = model.PlanType;
                existingPlan.SortOrder = model.SortOrder;
                existingPlan.UpdatedOn = DateTime.Now;

                await _context.SaveChangesAsync();

                if (Request.Headers["X-Requested-With"] == "XMLHttpRequest")
                    return Json(new { success = true, message = "Plan updated successfully!" });

                return RedirectToAction(nameof(Plans));
            }

            if (Request.Headers["X-Requested-With"] == "XMLHttpRequest")
                return Json(new { success = false, errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage) });

            return View(model);
        }

        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> CheckPlanSubscribers(int planId)
        {
            var activeSubscribers = await _context.PartnerSubscriptions
                .Include(s => s.ChannelPartner)
                .Where(s => s.PlanId == planId && s.Status == "Active" && s.EndDate > DateTime.Now)
                .Select(s => new { 
                    CompanyName = s.ChannelPartner!.CompanyName, 
                    StartDate = s.StartDate, 
                    EndDate = s.EndDate 
                })
                .ToListAsync();

            return Json(new { 
                hasActiveSubscribers = activeSubscribers.Any(),
                count = activeSubscribers.Count,
                subscribers = activeSubscribers
            });
        }

        [HttpPost]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> TogglePlan(int id, bool isActive)
        {
            var plan = await _context.SubscriptionPlans.FindAsync(id);
            if (plan == null)
                return NotFound();

            plan.IsActive = isActive;
            plan.UpdatedOn = DateTime.Now;
            await _context.SaveChangesAsync();

            return RedirectToAction(nameof(Plans));
        }

        // Admin: Manage Partner Subscriptions
        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> PartnerSubscriptions(string? search, string? status, int page = 1)
        {
            int pageSize = 20;
            
            var query = _context.PartnerSubscriptions
                .Include(s => s.ChannelPartner)
                .Include(s => s.Plan)
                .AsQueryable();

            // Apply search filter
            if (!string.IsNullOrEmpty(search))
            {
                query = query.Where(s => 
                    s.ChannelPartner!.CompanyName.Contains(search) ||
                    s.ChannelPartner.Email.Contains(search) ||
                    s.Plan!.PlanName.Contains(search));
            }

            // Apply status filter
            if (!string.IsNullOrEmpty(status))
            {
                query = query.Where(s => s.Status == status);
            }

            var totalCount = await query.CountAsync();
            var totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);

            var subscriptions = await query
                .OrderByDescending(s => s.CreatedOn)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            ViewBag.Search = search;
            ViewBag.Status = status;
            ViewBag.CurrentPage = page;
            ViewBag.TotalPages = totalPages;
            ViewBag.TotalCount = totalCount;

            return View(subscriptions);
        }

        // Admin: Get Partner Current Subscription for Upgrade Modal
        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> GetPartnerSubscription(int partnerId)
        {
            var currentSubscription = await _context.PartnerSubscriptions
                .Include(s => s.Plan)
                .Where(s => s.ChannelPartnerId == partnerId && s.Status == "Active")
                .FirstOrDefaultAsync();

            var scheduledSubscription = await _context.PartnerSubscriptions
                .Include(s => s.Plan)
                .Where(s => s.ChannelPartnerId == partnerId && s.Status == "Scheduled")
                .FirstOrDefaultAsync();

            var partner = await _context.ChannelPartners.FindAsync(partnerId);

            return Json(new
            {
                success = true,
                partner = new
                {
                    partnerId = partner?.PartnerId,
                    companyName = partner?.CompanyName,
                    email = partner?.Email
                },
                currentSubscription = currentSubscription != null ? new
                {
                    subscriptionId = currentSubscription.SubscriptionId,
                    planId = currentSubscription.PlanId,
                    planName = currentSubscription.Plan?.PlanName,
                    amount = currentSubscription.Amount,
                    billingCycle = currentSubscription.BillingCycle,
                    startDate = currentSubscription.StartDate.ToString("MMM dd, yyyy"),
                    endDate = currentSubscription.EndDate.ToString("MMM dd, yyyy"),
                    status = currentSubscription.Status
                } : null,
                scheduledSubscription = scheduledSubscription != null ? new
                {
                    subscriptionId = scheduledSubscription.SubscriptionId,
                    planId = scheduledSubscription.PlanId,
                    planName = scheduledSubscription.Plan?.PlanName,
                    amount = scheduledSubscription.Amount,
                    billingCycle = scheduledSubscription.BillingCycle,
                    startDate = scheduledSubscription.StartDate.ToString("MMM dd, yyyy"),
                    status = scheduledSubscription.Status
                } : null
            });
        }

        // Admin: Change Partner Plan (Direct Assignment without Payment)
        [HttpPost]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> AdminChangePlan(int partnerId, int newPlanId, string billingCycle, string reason)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            
            try
            {
                var partner = await _context.ChannelPartners.FindAsync(partnerId);
                if (partner == null)
                    return Json(new { success = false, message = "Partner not found" });

                var newPlan = await _context.SubscriptionPlans.FindAsync(newPlanId);
                if (newPlan == null)
                    return Json(new { success = false, message = "Plan not found" });

                var amount = billingCycle.ToLower() == "annual" ? newPlan.YearlyPrice : newPlan.MonthlyPrice;

                // Get current active subscription
                var currentSubscription = await _context.PartnerSubscriptions
                    .Where(s => s.ChannelPartnerId == partnerId && s.Status == "Active")
                    .FirstOrDefaultAsync();

                if (currentSubscription != null)
                {
                    // Expire current subscription
                    currentSubscription.Status = "Expired";
                    currentSubscription.UpdatedOn = DateTime.Now;
                    currentSubscription.CancellationReason = $"Admin changed plan - {reason}";
                    currentSubscription.CancelledOn = DateTime.Now;
                }

                // Cancel any scheduled subscriptions
                var scheduledSubscriptions = await _context.PartnerSubscriptions
                    .Where(s => s.ChannelPartnerId == partnerId && s.Status == "Scheduled")
                    .ToListAsync();

                foreach (var scheduled in scheduledSubscriptions)
                {
                    scheduled.Status = "Cancelled";
                    scheduled.CancelledOn = DateTime.Now;
                    scheduled.CancellationReason = $"Admin changed plan - {reason}";
                    scheduled.UpdatedOn = DateTime.Now;
                }

                // Create new active subscription
                var newSubscription = new PartnerSubscriptionModel
                {
                    ChannelPartnerId = partnerId,
                    PlanId = newPlanId,
                    BillingCycle = billingCycle,
                    Amount = amount,
                    StartDate = DateTime.Now,
                    EndDate = billingCycle.ToLower() == "annual" ? DateTime.Now.AddYears(1) : DateTime.Now.AddMonths(1),
                    Status = "Active",
                    PaymentMethod = "Admin Assignment",
                    PaymentTransactionId = $"admin_{DateTime.Now.Ticks}",
                    LastPaymentDate = DateTime.Now,
                    NextPaymentDate = billingCycle.ToLower() == "annual" ? DateTime.Now.AddYears(1) : DateTime.Now.AddMonths(1),
                    AutoRenew = false,
                    CreatedOn = DateTime.Now,
                    UpdatedOn = DateTime.Now
                };

                _context.PartnerSubscriptions.Add(newSubscription);

                // Create payment transaction record
                var paymentTransaction = new PaymentTransactionModel
                {
                    ChannelPartnerId = partnerId,
                    SubscriptionId = newSubscription.SubscriptionId,
                    TransactionReference = $"ADMIN_{DateTime.Now:yyyyMMddHHmmss}",
                    Amount = amount,
                    Currency = "INR",
                    Status = "Success",
                    TransactionType = "Admin Assignment",
                    PaymentMethod = "Admin",
                    TransactionDate = DateTime.Now,
                    CompletedDate = DateTime.Now,
                    Description = $"Admin assigned {newPlan.PlanName} plan ({billingCycle})",
                    PlanName = newPlan.PlanName,
                    BillingCycle = billingCycle,
                    CreatedOn = DateTime.Now
                };

                _context.PaymentTransactions.Add(paymentTransaction);
                
                await _context.SaveChangesAsync();
                await transaction.CommitAsync();

                _logger.LogInformation($"Admin changed partner {partnerId} plan to {newPlan.PlanName}. Reason: {reason}");

                return Json(new
                {
                    success = true,
                    message = $"Successfully assigned {newPlan.PlanName} ({billingCycle}) plan to {partner.CompanyName}"
                });
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                _logger.LogError(ex, $"Error changing partner plan for partner {partnerId}");
                return Json(new { success = false, message = $"Error: {ex.Message}" });
            }
        }

        // Membership Addons
        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> Addons()
        {
            var addons = await _context.SubscriptionAddons
                .OrderBy(a => a.SortOrder)
                .ThenBy(a => a.AddonName)
                .ToListAsync();
            
            return View(addons);
        }

        // Subscription Transactions
        [HttpGet]
        public async Task<IActionResult> Transactions(string? status, string? type, DateTime? fromDate, DateTime? toDate)
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            var transactionsQuery = _context.PaymentTransactions
                .Include(t => t.ChannelPartner)
                .Include(t => t.Subscription)
                .ThenInclude(s => s!.Plan)
                .AsQueryable();

            // Filter by partner if not admin
            if (role?.ToLower() == "partner" && channelPartnerId.HasValue)
            {
                transactionsQuery = transactionsQuery.Where(t => t.ChannelPartnerId == channelPartnerId.Value);
            }

            // Apply filters
            if (!string.IsNullOrEmpty(status))
                transactionsQuery = transactionsQuery.Where(t => t.Status == status);

            if (!string.IsNullOrEmpty(type))
                transactionsQuery = transactionsQuery.Where(t => t.TransactionType == type);

            if (fromDate.HasValue)
                transactionsQuery = transactionsQuery.Where(t => t.TransactionDate >= fromDate.Value);

            if (toDate.HasValue)
                transactionsQuery = transactionsQuery.Where(t => t.TransactionDate <= toDate.Value.AddDays(1));

            var transactions = await transactionsQuery
                .OrderByDescending(t => t.TransactionDate)
                .ToListAsync();

            // Get pending refund subscriptions
            List<PartnerSubscriptionModel> pendingRefundSubscriptions = new List<PartnerSubscriptionModel>();
            
            // Show pending refunds when filtering by "Refund" type or when no type filter is applied
            bool showPendingRefunds = string.IsNullOrEmpty(type) || type == "Refund";
            
            if (showPendingRefunds)
            {
                if (role?.ToLower() == "partner" && channelPartnerId.HasValue)
                {
                    var refundQuery = _context.PartnerSubscriptions
                        .Include(s => s.Plan)
                        .Include(s => s.ChannelPartner)
                        .Where(s => s.ChannelPartnerId == channelPartnerId.Value 
                                    && s.Status == "Cancelled" 
                                    && s.CancellationReason != null
                                    && s.CancellationReason.Contains("Refund Pending"));
                    
                    // Apply date filters to pending refunds as well
                    if (fromDate.HasValue)
                        refundQuery = refundQuery.Where(s => s.CancelledOn >= fromDate.Value);
                    
                    if (toDate.HasValue)
                        refundQuery = refundQuery.Where(s => s.CancelledOn <= toDate.Value.AddDays(1));
                    
                    pendingRefundSubscriptions = await refundQuery
                        .OrderByDescending(s => s.CancelledOn)
                        .ToListAsync();
                }
                else if (role?.ToLower() == "admin")
                {
                    var refundQuery = _context.PartnerSubscriptions
                        .Include(s => s.Plan)
                        .Include(s => s.ChannelPartner)
                        .Where(s => s.Status == "Cancelled" 
                                    && s.CancellationReason != null
                                    && s.CancellationReason.Contains("Refund Pending"));
                    
                    // Apply date filters to pending refunds as well
                    if (fromDate.HasValue)
                        refundQuery = refundQuery.Where(s => s.CancelledOn >= fromDate.Value);
                    
                    if (toDate.HasValue)
                        refundQuery = refundQuery.Where(s => s.CancelledOn <= toDate.Value.AddDays(1));
                    
                    pendingRefundSubscriptions = await refundQuery
                        .OrderByDescending(s => s.CancelledOn)
                        .ToListAsync();
                }
            }

            ViewBag.Status = status;
            ViewBag.Type = type;
            ViewBag.FromDate = fromDate?.ToString("yyyy-MM-dd");
            ViewBag.ToDate = toDate?.ToString("yyyy-MM-dd");
            ViewBag.IsAdmin = role?.ToLower() == "admin";
            ViewBag.PendingRefundSubscriptions = pendingRefundSubscriptions;

            return View(transactions);
        }

        // Partner Plan Selection & Management
        [HttpGet]
        public async Task<IActionResult> MyPlan()
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            if (!channelPartnerId.HasValue)
                return RedirectToAction("AccessDenied", "Home");

            var currentSubscription = await _subscriptionService.GetActiveSubscriptionAsync(channelPartnerId.Value);
            
            // Update current usage counts
            if (currentSubscription != null)
            {
                // Count approved agents for this partner (Status = "Approved")
                currentSubscription.CurrentAgentCount = await _context.Agents
                    .Where(a => a.ChannelPartnerId == channelPartnerId.Value && a.Status == "Approved")
                    .CountAsync();
                
                // Count leads created in current billing cycle (from subscription start date)
                currentSubscription.CurrentMonthLeads = await _context.Leads
                    .Where(l => l.ChannelPartnerId == channelPartnerId.Value && 
                               l.CreatedOn >= currentSubscription.StartDate)
                    .CountAsync();
                
                // Update the database with current counts
                currentSubscription.UpdatedOn = DateTime.Now;
                await _context.SaveChangesAsync();
            }
            
            var availablePlans = await _subscriptionService.GetAvailablePlansAsync();

            // Get scheduled subscription if any
            var scheduledSubscription = await _context.PartnerSubscriptions
                .Include(s => s.Plan)
                .Where(s => s.ChannelPartnerId == channelPartnerId.Value && s.Status == "Scheduled")
                .OrderByDescending(s => s.CreatedOn)
                .FirstOrDefaultAsync();

            // Get cancelled subscriptions with pending refunds
            var cancelledWithPendingRefund = await _context.PartnerSubscriptions
                .Include(s => s.Plan)
                .Where(s => s.ChannelPartnerId == channelPartnerId.Value && 
                           s.Status == "Cancelled" && 
                           s.CancellationReason != null &&
                           s.CancellationReason.Contains("Refund Pending"))
                .ToListAsync();

            ViewBag.CurrentSubscription = currentSubscription;
            ViewBag.ScheduledSubscription = scheduledSubscription;
            ViewBag.CancelledWithPendingRefund = cancelledWithPendingRefund;
            ViewBag.AvailablePlans = availablePlans;
            ViewBag.ChannelPartnerId = channelPartnerId.Value;
            ViewBag.RazorpayKeyId = _razorpayService.GetKeyId(); // Add Razorpay key

            return View();
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CancelScheduledPlan(int subscriptionId)
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            if (!channelPartnerId.HasValue)
                return Json(new { success = false, message = "Partner context not found" });

            try
            {
                var scheduledSubscription = await _context.PartnerSubscriptions
                    .Include(s => s.Plan)
                    .Where(s => s.SubscriptionId == subscriptionId && 
                               s.ChannelPartnerId == channelPartnerId.Value && 
                               s.Status == "Scheduled")
                    .FirstOrDefaultAsync();

                if (scheduledSubscription == null)
                {
                    return Json(new { success = false, message = "Scheduled subscription not found" });
                }

                // Get the original payment transaction to fetch card details
                var paymentTransaction = await _context.PaymentTransactions
                    .Where(t => t.SubscriptionId == subscriptionId && t.Status == "Success")
                    .OrderByDescending(t => t.TransactionDate)
                    .FirstOrDefaultAsync();

                string cardInfo = "original payment method";
                if (paymentTransaction != null && 
                    !string.IsNullOrEmpty(paymentTransaction.CardNetwork) && 
                    !string.IsNullOrEmpty(paymentTransaction.CardLast4))
                {
                    cardInfo = $"{paymentTransaction.CardNetwork} **** {paymentTransaction.CardLast4}";
                    if (!string.IsNullOrEmpty(paymentTransaction.CardType))
                    {
                        cardInfo += $" ({paymentTransaction.CardType})";
                    }
                }

                // Cancel the scheduled subscription
                scheduledSubscription.Status = "Cancelled";
                scheduledSubscription.CancelledOn = DateTime.Now;
                scheduledSubscription.CancellationReason = $"Cancelled by user - Refund Pending: ₹{scheduledSubscription.Amount:N0}. Refund will be processed to {cardInfo}";
                scheduledSubscription.UpdatedOn = DateTime.Now;

                await _context.SaveChangesAsync();

                _logger.LogInformation($"User cancelled scheduled subscription {subscriptionId} for {scheduledSubscription.Plan?.PlanName}. Refund pending: ₹{scheduledSubscription.Amount}");

                return Json(new { 
                    success = true,
                    refundPending = true,
                    refundAmount = scheduledSubscription.Amount,
                    message = $"Your scheduled {scheduledSubscription.Plan?.PlanName} plan has been cancelled successfully." 
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error cancelling scheduled subscription {subscriptionId}");
                return Json(new { success = false, message = "Failed to cancel subscription. Please try again or contact support." });
            }
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> SelectPlan(int planId, string billingCycle)
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            if (!channelPartnerId.HasValue)
                return Json(new { success = false, message = "Partner context not found" });

            var plan = await _context.SubscriptionPlans.FindAsync(planId);
            if (plan == null)
                return Json(new { success = false, message = "Invalid plan selected" });

            // Get current active subscription
            var currentSubscription = await _context.PartnerSubscriptions
                .Where(s => s.ChannelPartnerId == channelPartnerId.Value && s.Status == "Active")
                .FirstOrDefaultAsync();

            var amount = billingCycle.ToLower() == "annual" ? plan.YearlyPrice : plan.MonthlyPrice;

            // If no current subscription, create immediate subscription
            if (currentSubscription == null)
            {
                try
                {
                    // Create Razorpay order for immediate subscription
                    var orderId = await _razorpayService.CreateOrderAsync(amount, "INR", $"subscription_{channelPartnerId}_{planId}");
                    
                    return Json(new { 
                        success = true, 
                        orderId = orderId,
                        amount = amount * 100, // Razorpay expects amount in paise
                        planName = plan.PlanName,
                        billingCycle = billingCycle
                    });
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error creating Razorpay order");
                    return Json(new { success = false, message = "Failed to create payment order" });
                }
            }
            else
            {
                // Check for existing scheduled subscriptions
                var existingScheduled = await _context.PartnerSubscriptions
                    .Include(s => s.Plan)
                    .Where(s => s.ChannelPartnerId == channelPartnerId.Value && s.Status == "Scheduled")
                    .FirstOrDefaultAsync();

                // Create scheduled subscription (starts after current expires)
                var startDate = currentSubscription.EndDate.AddDays(1);
                var endDate = billingCycle.ToLower() == "annual" ? startDate.AddYears(1) : startDate.AddMonths(1);

                // Calculate amount with credit adjustment
                decimal amountToPay = amount;
                decimal creditAmount = 0;
                string creditInfo = "";

                if (existingScheduled != null)
                {
                    // User already paid for a scheduled plan, apply credit
                    creditAmount = existingScheduled.Amount;
                    
                    // Check if it's the same plan (same price and same billing cycle)
                    if (existingScheduled.PlanId == planId && existingScheduled.BillingCycle.Equals(billingCycle, StringComparison.OrdinalIgnoreCase))
                    {
                        // Same plan already scheduled
                        return Json(new { 
                            success = false, 
                            isSamePlan = true,
                            existingPlanName = existingScheduled.Plan?.PlanName,
                            existingAmount = creditAmount,
                            scheduledDate = (existingScheduled.StartDate).ToString("MMMM dd, yyyy"),
                            subscriptionId = existingScheduled.SubscriptionId,
                            message = $"You already have {existingScheduled.Plan?.PlanName} scheduled for activation on {existingScheduled.StartDate:MMMM dd, yyyy}." 
                        });
                    }
                    
                    amountToPay = amount - creditAmount;
                    
                    if (amountToPay <= 0)
                    {
                        // Downgrade scenario - new plan is cheaper or same price
                        // Don't allow downgrades, require support intervention for refunds
                        return Json(new { 
                            success = false, 
                            message = $"You already have {existingScheduled.Plan?.PlanName} (₹{creditAmount:N0}) scheduled for the same activation date. " +
                                     $"The {plan.PlanName} plan costs ₹{amount:N0}. " +
                                     $"To downgrade and receive a refund of ₹{Math.Abs(amountToPay):N0}, please contact our support team.",
                            isDowngrade = true
                        });
                    }
                    
                    creditInfo = $"Credit of ₹{creditAmount:N0} applied from {existingScheduled.Plan?.PlanName}";
                }

                try
                {
                    // Create Razorpay order for the adjusted amount (difference only)
                    var orderId = await _razorpayService.CreateOrderAsync(amountToPay, "INR", $"scheduled_{channelPartnerId}_{planId}");
                    
                    return Json(new { 
                        success = true, 
                        orderId = orderId,
                        amount = amountToPay * 100, // Amount to pay in paise
                        fullAmount = amount,
                        creditAmount = creditAmount,
                        amountToPay = amountToPay,
                        planName = plan.PlanName,
                        billingCycle = billingCycle,
                        isScheduled = true,
                        startDate = startDate.ToString("dd/MM/yyyy"),
                        hasExistingScheduled = existingScheduled != null,
                        existingPlanName = existingScheduled?.Plan?.PlanName,
                        creditInfo = creditInfo
                    });
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error creating Razorpay order for scheduled subscription");
                    return Json(new { success = false, message = "Failed to create payment order" });
                }
            }
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> ConfirmPayment(string razorpayPaymentId, string razorpayOrderId, string razorpaySignature, int planId, string billingCycle, string? paymentStatus = null)
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            if (!channelPartnerId.HasValue)
                return Json(new { success = false, message = "Partner context not found", errorCode = "NO_PARTNER" });

            // Check if payment failed at Razorpay level (before verification)
            if (!string.IsNullOrEmpty(paymentStatus) && paymentStatus.ToLower() == "failed")
            {
                _logger.LogWarning($"Payment failed at Razorpay level for order {razorpayOrderId}");
                
                // Record failed payment
                var failedTransaction = new PaymentTransactionModel
                {
                    ChannelPartnerId = channelPartnerId.Value,
                    TransactionReference = razorpayOrderId ?? "unknown",
                    RazorpayOrderId = razorpayOrderId,
                    RazorpayPaymentId = razorpayPaymentId,
                    Status = "Failed",
                    TransactionType = "Payment Failure",
                    PaymentMethod = "Razorpay",
                    TransactionDate = DateTime.Now,
                    CompletedDate = DateTime.Now,
                    Description = "Payment failed at gateway",
                    CreatedOn = DateTime.Now
                };
                
                _context.PaymentTransactions.Add(failedTransaction);
                await _context.SaveChangesAsync();
                
                return Json(new { 
                    success = false, 
                    message = "Payment was declined. Please try again or use a different payment method.",
                    errorCode = "PAYMENT_FAILED",
                    canRetry = true
                });
            }

            // Use a database transaction to ensure atomicity
            using var transaction = await _context.Database.BeginTransactionAsync();
            
            try
            {
                _logger.LogInformation($"Starting payment confirmation for partner {channelPartnerId}, plan {planId}");

                // Verify payment signature
                if (!_razorpayService.VerifyPaymentSignature(razorpayPaymentId, razorpayOrderId, razorpaySignature))
                {
                    _logger.LogWarning($"Payment verification failed for order {razorpayOrderId}");
                    
                    // Record signature verification failure
                    var failedTransaction = new PaymentTransactionModel
                    {
                        ChannelPartnerId = channelPartnerId.Value,
                        TransactionReference = razorpayOrderId,
                        RazorpayOrderId = razorpayOrderId,
                        RazorpayPaymentId = razorpayPaymentId,
                        Status = "Failed",
                        TransactionType = "Verification Failed",
                        PaymentMethod = "Razorpay",
                        TransactionDate = DateTime.Now,
                        CompletedDate = DateTime.Now,
                        Description = "Payment signature verification failed",
                        CreatedOn = DateTime.Now
                    };
                    
                    _context.PaymentTransactions.Add(failedTransaction);
                    await _context.SaveChangesAsync();
                    
                    return Json(new { 
                        success = false, 
                        message = "Payment verification failed. If amount was deducted, it will be refunded within 5-7 business days.",
                        errorCode = "VERIFICATION_FAILED",
                        canRetry = false
                    });
                }

                // Fetch payment details from Razorpay to get card information
                string? cardType = null;
                string? cardNetwork = null;
                string? cardLast4 = null;
                string? bankName = null;
                
                try
                {
                    var (success, paymentDetails) = await _razorpayService.FetchPaymentAsync(razorpayPaymentId);
                    if (success && paymentDetails.HasValue)
                    {
                        var payment = paymentDetails.Value;
                        
                        // Extract card details if available
                        if (payment.TryGetProperty("method", out var method) && method.GetString() == "card")
                        {
                            if (payment.TryGetProperty("card", out var card))
                            {
                                cardType = card.TryGetProperty("type", out var type) ? type.GetString() : null;
                                cardNetwork = card.TryGetProperty("network", out var network) ? network.GetString() : null;
                                cardLast4 = card.TryGetProperty("last4", out var last4) ? last4.GetString() : null;
                                
                                if (card.TryGetProperty("issuer", out var issuer))
                                {
                                    bankName = issuer.GetString();
                                }
                                else if (card.TryGetProperty("name", out var name))
                                {
                                    bankName = name.GetString();
                                }
                            }
                        }
                        
                        _logger.LogInformation($"Card details fetched: Type={cardType}, Network={cardNetwork}, Last4={cardLast4}, Bank={bankName}");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to fetch card details from Razorpay, continuing with payment processing");
                }

                var plan = await _context.SubscriptionPlans.FindAsync(planId);
                if (plan == null)
                {
                    _logger.LogWarning($"Plan {planId} not found");
                    await transaction.RollbackAsync();
                    return Json(new { success = false, message = "Invalid plan selected", errorCode = "INVALID_PLAN" });
                }

                var amount = billingCycle.ToLower() == "annual" ? plan.YearlyPrice : plan.MonthlyPrice;
                _logger.LogInformation($"Plan found: {plan.PlanName}, Amount: {amount}");

                var currentSubscription = await _context.PartnerSubscriptions
                    .Where(s => s.ChannelPartnerId == channelPartnerId.Value && s.Status == "Active")
                    .FirstOrDefaultAsync();

                _logger.LogInformation($"Current subscription exists: {currentSubscription != null}");

                if (currentSubscription != null)
                {
                    _logger.LogInformation($"Creating scheduled subscription, current expires: {currentSubscription.EndDate}");
                    
                    // Calculate credit from existing scheduled subscriptions
                    decimal creditAmount = 0;
                    string creditDescription = "";
                    
                    // Cancel existing scheduled subscriptions instead of deleting them
                    // (they have payment transactions referencing them via FK)
                    var existingScheduled = await _context.PartnerSubscriptions
                        .Include(s => s.Plan)
                        .Where(s => s.ChannelPartnerId == channelPartnerId.Value && s.Status == "Scheduled")
                        .ToListAsync();

                    if (existingScheduled.Any())
                    {
                        foreach (var scheduled in existingScheduled)
                        {
                            creditAmount += scheduled.Amount;
                            scheduled.Status = "Cancelled";
                            scheduled.CancelledOn = DateTime.Now;
                            scheduled.CancellationReason = "Replaced by new scheduled plan - credit applied";
                            scheduled.UpdatedOn = DateTime.Now;
                        }
                        
                        // Validate that new plan is not cheaper (downgrade)
                        if (amount <= creditAmount)
                        {
                            await transaction.RollbackAsync();
                            _logger.LogWarning($"Attempted downgrade from ₹{creditAmount} to ₹{amount}");
                            return Json(new { 
                                success = false, 
                                isDowngrade = true,
                                existingPlanName = existingScheduled.First().Plan?.PlanName,
                                existingAmount = creditAmount,
                                newPlanName = plan.PlanName,
                                newAmount = amount,
                                refundAmount = creditAmount - amount,
                                message = $"Cannot process downgrade. You already paid ₹{creditAmount:N0} for {existingScheduled.First().Plan?.PlanName}. The {plan.PlanName} costs ₹{amount:N0}. Please contact support for assistance with downgrades and refunds." 
                            });
                        }
                        
                        await _context.SaveChangesAsync();
                        _logger.LogInformation($"Cancelled {existingScheduled.Count} existing scheduled subscriptions. Total credit: ₹{creditAmount}");
                        
                        creditDescription = $" (Credit of ₹{creditAmount:N0} applied from {existingScheduled.First().Plan?.PlanName})";
                    }

                    // Create scheduled subscription first
                    var startDate = currentSubscription.EndDate.AddDays(1);
                    _logger.LogInformation($"Creating scheduled subscription starting: {startDate}");
                    
                    var scheduledSubscription = await _subscriptionService.CreateScheduledSubscriptionAsync(
                        channelPartnerId.Value, 
                        planId, 
                        billingCycle, 
                        startDate
                    );

                    _logger.LogInformation($"Scheduled subscription created with ID: {scheduledSubscription.SubscriptionId}");

                    // Now create payment transaction with subscription reference
                    var paymentTransaction = new PaymentTransactionModel
                    {
                        ChannelPartnerId = channelPartnerId.Value,
                        SubscriptionId = scheduledSubscription.SubscriptionId,
                        TransactionReference = razorpayOrderId,
                        RazorpayPaymentId = razorpayPaymentId,
                        RazorpayOrderId = razorpayOrderId,
                        RazorpaySignature = razorpaySignature,
                        Amount = amount, // Full plan amount (before credit)
                        TransactionType = "Scheduled Payment",
                        Status = "Success",
                        PaymentMethod = "Razorpay",
                        TransactionDate = DateTime.Now,
                        CompletedDate = DateTime.Now,
                        PlanName = plan.PlanName,
                        BillingCycle = billingCycle,
                        DiscountAmount = creditAmount, // Credit stored as discount
                        NetAmount = amount - creditAmount, // Actual amount paid
                        Description = $"Scheduled subscription payment for {plan.PlanName} plan{creditDescription}",
                        CardType = cardType,
                        CardNetwork = cardNetwork,
                        CardLast4 = cardLast4,
                        BankName = bankName
                    };

                    _context.PaymentTransactions.Add(paymentTransaction);
                    await _context.SaveChangesAsync();
                    _logger.LogInformation($"Transaction created with ID: {paymentTransaction.TransactionId}");

                    // Update scheduled subscription with payment transaction reference
                    // Re-fetch the subscription to ensure it's tracked by the current context
                    var subscriptionToUpdate = await _context.PartnerSubscriptions
                        .FirstOrDefaultAsync(s => s.SubscriptionId == scheduledSubscription.SubscriptionId);
                    
                    if (subscriptionToUpdate != null)
                    {
                        subscriptionToUpdate.PaymentTransactionId = paymentTransaction.TransactionId.ToString();
                        subscriptionToUpdate.LastPaymentDate = DateTime.Now;
                        await _context.SaveChangesAsync();
                        _logger.LogInformation($"Updated scheduled subscription with payment reference");
                    }

                    // Commit the database transaction
                    await transaction.CommitAsync();

                    var netAmountPaid = amount - creditAmount;
                    var message = existingScheduled.Any()
                        ? creditAmount > 0 
                            ? $"Payment successful! ₹{netAmountPaid:N0} paid (₹{creditAmount:N0} credit applied from previous plan). Your {plan.PlanName} plan will activate on {startDate:dd/MM/yyyy}."
                            : $"Payment successful! ₹{netAmountPaid:N0} received. Previous scheduled plan replaced. Your new {plan.PlanName} plan will activate on {startDate:dd/MM/yyyy}."
                        : $"Payment successful! ₹{netAmountPaid:N0} received. Your new {plan.PlanName} plan will activate on {startDate:dd/MM/yyyy}.";

                    return Json(new { success = true, message });
                }
                else
                {
                    _logger.LogInformation("Creating immediate subscription");
                    
                    // Create immediate subscription first
                    var subscription = await _subscriptionService.CreateSubscriptionAsync(
                        channelPartnerId.Value, 
                        planId, 
                        billingCycle, 
                        string.Empty // We'll set this after creating transaction
                    );

                    _logger.LogInformation($"Immediate subscription created with ID: {subscription.SubscriptionId}");

                    // Create payment transaction record
                    var paymentTransaction = new PaymentTransactionModel
                    {
                        ChannelPartnerId = channelPartnerId.Value,
                        SubscriptionId = subscription.SubscriptionId,
                        TransactionReference = razorpayOrderId,
                        RazorpayPaymentId = razorpayPaymentId,
                        RazorpayOrderId = razorpayOrderId,
                        RazorpaySignature = razorpaySignature,
                        Amount = amount,
                        TransactionType = "Payment",
                        Status = "Success",
                        PaymentMethod = "Razorpay",
                        TransactionDate = DateTime.Now,
                        CompletedDate = DateTime.Now,
                        PlanName = plan.PlanName,
                        BillingCycle = billingCycle,
                        NetAmount = amount,
                        Description = $"Subscription payment for {plan.PlanName} plan",
                        CardType = cardType,
                        CardNetwork = cardNetwork,
                        CardLast4 = cardLast4,
                        BankName = bankName
                    };

                    _context.PaymentTransactions.Add(paymentTransaction);
                    await _context.SaveChangesAsync();
                    _logger.LogInformation($"Transaction created with ID: {paymentTransaction.TransactionId}");

                    // Update subscription with payment transaction reference
                    // Re-fetch the subscription to ensure it's tracked by the current context
                    var subscriptionToUpdate = await _context.PartnerSubscriptions
                        .FirstOrDefaultAsync(s => s.SubscriptionId == subscription.SubscriptionId);
                    
                    if (subscriptionToUpdate != null)
                    {
                        subscriptionToUpdate.PaymentTransactionId = paymentTransaction.TransactionId.ToString();
                        subscriptionToUpdate.LastPaymentDate = DateTime.Now;
                        await _context.SaveChangesAsync();
                        _logger.LogInformation($"Updated subscription with payment reference");
                    }

                    // Commit the database transaction
                    await transaction.CommitAsync();

                    return Json(new { success = true, message = $"Payment successful! ₹{amount:N0} received. Your {plan.PlanName} subscription is now active." });
                }
            }
            catch (Exception ex)
            {
                // Rollback the transaction on error
                await transaction.RollbackAsync();
                
                _logger.LogError(ex, $"Error processing payment confirmation for partner {channelPartnerId}, plan {planId}");
                
                // Log inner exception details for better debugging
                var innerMessage = ex.InnerException?.Message ?? "No inner exception";
                var innerStackTrace = ex.InnerException?.StackTrace ?? "No stack trace";
                _logger.LogError($"Inner Exception: {innerMessage}");
                _logger.LogError($"Inner Stack Trace: {innerStackTrace}");
                
                // Provide detailed error message for debugging
                var errorDetails = ex.InnerException != null 
                    ? $"{ex.Message} - Inner: {ex.InnerException.Message}" 
                    : ex.Message;
                
                return Json(new { success = false, message = $"Payment processing failed: {errorDetails}" });
            }
        }

        // Admin: Manage Partner Subscriptions
        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> ManagePartnerSubscriptions(string? search, int? plan, string? billing, DateTime? fromDate, DateTime? toDate, int page = 1)
        {
            const int pageSize = 10;
            
            var query = _context.PartnerSubscriptions
                .Include(s => s.ChannelPartner)
                .Include(s => s.Plan)
                .Where(s => s.Status == "Active")
                .AsQueryable();

            // Apply filters
            if (!string.IsNullOrEmpty(search))
                query = query.Where(s => s.ChannelPartner!.CompanyName.Contains(search));

            if (plan.HasValue)
                query = query.Where(s => s.PlanId == plan.Value);

            if (!string.IsNullOrEmpty(billing))
                query = query.Where(s => s.BillingCycle == billing);

            if (fromDate.HasValue)
                query = query.Where(s => s.StartDate >= fromDate.Value);

            if (toDate.HasValue)
                query = query.Where(s => s.StartDate <= toDate.Value);

            var totalCount = await query.CountAsync();
            var totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);

            var subscriptions = await query
                .OrderByDescending(s => s.CreatedOn)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            // Get scheduled subscriptions for each partner
            var partnerIds = subscriptions.Select(s => s.ChannelPartnerId).Distinct().ToList();
            var scheduledSubscriptions = await _context.PartnerSubscriptions
                .Include(s => s.Plan)
                .Where(s => partnerIds.Contains(s.ChannelPartnerId) && s.Status == "Scheduled")
                .Select(s => new {
                    s.ChannelPartnerId,
                    s.PlanId,
                    s.BillingCycle,
                    PlanName = s.Plan!.PlanName
                })
                .ToListAsync();

            ViewBag.ScheduledSubscriptions = scheduledSubscriptions;

            var availablePlans = await _subscriptionService.GetAvailablePlansAsync();
            var allPlans = await _context.SubscriptionPlans.ToListAsync();

            ViewBag.AvailablePlans = availablePlans;
            ViewBag.Plans = allPlans;
            ViewBag.Search = search;
            ViewBag.SelectedPlan = plan?.ToString();
            ViewBag.SelectedBilling = billing;
            ViewBag.FromDate = fromDate?.ToString("yyyy-MM-dd");
            ViewBag.ToDate = toDate?.ToString("yyyy-MM-dd");
            ViewBag.CurrentPage = page;
            ViewBag.TotalPages = totalPages;
            ViewBag.TotalCount = totalCount;

            return View(subscriptions);
        }

        // Admin: View Pending Refunds
        [HttpGet]
        [RoleAuthorize("Admin")]
        public async Task<IActionResult> PendingRefunds(string? search, int page = 1)
        {
            const int pageSize = 20;
            
            // Get cancelled subscriptions with "Refund Pending" in reason
            var query = _context.PartnerSubscriptions
                .Include(s => s.ChannelPartner)
                .Include(s => s.Plan)
                .Where(s => s.Status == "Cancelled" && 
                           s.CancellationReason != null && 
                           s.CancellationReason.Contains("Refund Pending"))
                .AsQueryable();

            // Apply search filter
            if (!string.IsNullOrEmpty(search))
                query = query.Where(s => s.ChannelPartner!.CompanyName.Contains(search) || 
                                        s.ChannelPartner!.ContactPerson.Contains(search));

            var totalCount = await query.CountAsync();
            var totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);

            var cancelledSubscriptions = await query
                .OrderByDescending(s => s.CancelledOn)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            ViewBag.Search = search;
            ViewBag.CurrentPage = page;
            ViewBag.TotalPages = totalPages;
            ViewBag.TotalCount = totalCount;
            ViewBag.TotalRefundAmount = cancelledSubscriptions.Sum(s => s.Amount);

            return View(cancelledSubscriptions);
        }

        // Admin: Mark Refund as Processed (with Razorpay integration)
        [HttpPost]
        [RoleAuthorize("Admin")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> MarkRefundProcessed(int subscriptionId, string refundNotes)
        {
            try
            {
                var subscription = await _context.PartnerSubscriptions
                    .Include(s => s.ChannelPartner)
                    .Include(s => s.Plan)
                    .FirstOrDefaultAsync(s => s.SubscriptionId == subscriptionId);

                if (subscription == null)
                    return Json(new { success = false, message = "Subscription not found" });

                // Find the payment transaction for this subscription using SubscriptionId
                var transaction = await _context.PaymentTransactions
                    .Where(t => t.SubscriptionId == subscriptionId 
                        && t.Status == "Success"
                        && t.TransactionType != "Refund")
                    .OrderByDescending(t => t.TransactionDate)
                    .FirstOrDefaultAsync();

                if (transaction == null || string.IsNullOrEmpty(transaction.RazorpayPaymentId))
                {
                    // Manual refund - just update status
                    subscription.CancellationReason = $"Cancelled by user - Refund Processed Manually: ₹{subscription.Amount:N0}. {refundNotes}";
                    subscription.UpdatedOn = DateTime.Now;
                    await _context.SaveChangesAsync();

                    _logger.LogInformation($"Admin marked manual refund as processed for subscription {subscriptionId}");
                    return Json(new { 
                        success = true, 
                        message = $"Manual refund of ₹{subscription.Amount:N0} marked as processed for {subscription.ChannelPartner?.CompanyName}"
                    });
                }

                // Process Razorpay refund using RazorpayPaymentId
                var razorpayService = HttpContext.RequestServices.GetRequiredService<RazorpayService>();
                
                _logger.LogInformation($"Processing Razorpay refund for subscription {subscriptionId}. Payment ID: {transaction.RazorpayPaymentId}, Amount: {subscription.Amount}");
                
                var (success, refundId, message) = await razorpayService.CreateRefundAsync(
                    transaction.RazorpayPaymentId, 
                    subscription.Amount, 
                    refundNotes
                );

                if (success)
                {
                    // Update subscription
                    subscription.CancellationReason = $"Cancelled by user - Refund Processed: ₹{subscription.Amount:N0}. Refund ID: {refundId}. {refundNotes}";
                    subscription.UpdatedOn = DateTime.Now;

                    // Create refund transaction record
                    var refundTransaction = new PaymentTransactionModel
                    {
                        ChannelPartnerId = subscription.ChannelPartnerId,
                        SubscriptionId = subscriptionId,
                        TransactionReference = refundId,
                        RazorpayPaymentId = refundId,
                        RazorpayOrderId = transaction.RazorpayOrderId,
                        Amount = subscription.Amount,
                        Currency = transaction.Currency ?? "INR",
                        TransactionType = "Refund",
                        Status = "Success",
                        PaymentMethod = "Razorpay",
                        TransactionDate = DateTime.Now,
                        CompletedDate = DateTime.Now,
                        Description = $"Refund for Subscription #{subscriptionId} - {subscription.Plan?.PlanName} - {refundNotes}",
                        CardType = transaction.CardType,
                        CardNetwork = transaction.CardNetwork,
                        CardLast4 = transaction.CardLast4,
                        BankName = transaction.BankName,
                        PlanName = subscription.Plan?.PlanName,
                        BillingCycle = subscription.BillingCycle,
                        NetAmount = subscription.Amount
                    };
                    _context.PaymentTransactions.Add(refundTransaction);

                    await _context.SaveChangesAsync();

                    _logger.LogInformation($"Razorpay refund created for subscription {subscriptionId}. Refund ID: {refundId}");

                    return Json(new { 
                        success = true, 
                        message = $"✓ Refund of ₹{subscription.Amount:N0} processed successfully!<br/><small>Refund ID: {refundId}</small><br/>{message}"
                    });
                }
                else
                {
                    _logger.LogError($"Razorpay refund failed for subscription {subscriptionId}: {message}");
                    return Json(new { success = false, message = $"Razorpay refund failed: {message}" });
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error processing refund for subscription {subscriptionId}");
                return Json(new { success = false, message = $"Error: {ex.Message}" });
            }
        }

        [HttpPost]
        [RoleAuthorize("Admin")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> AdminUpgradePlan(int channelPartnerId, int newPlanId, string billingCycle)
        {
            try
            {
                var plan = await _context.SubscriptionPlans.FindAsync(newPlanId);
                if (plan == null)
                    return Json(new { success = false, message = "Invalid plan selected" });

                // Get current active subscription
                var currentSubscription = await _context.PartnerSubscriptions
                    .Where(s => s.ChannelPartnerId == channelPartnerId && s.Status == "Active")
                    .FirstOrDefaultAsync();

                if (currentSubscription == null)
                    return Json(new { success = false, message = "No active subscription found" });

                // Check for existing scheduled subscriptions and remove them
                var existingScheduled = await _context.PartnerSubscriptions
                    .Where(s => s.ChannelPartnerId == channelPartnerId && s.Status == "Scheduled")
                    .ToListAsync();

                if (existingScheduled.Any())
                {
                    _context.PartnerSubscriptions.RemoveRange(existingScheduled);
                    await _context.SaveChangesAsync();
                }

                var amount = billingCycle.ToLower() == "annual" ? plan.YearlyPrice : plan.MonthlyPrice;
                var startDate = currentSubscription.EndDate.AddDays(1); // Start after current expires
                var endDate = billingCycle.ToLower() == "annual" ? startDate.AddYears(1) : startDate.AddMonths(1);

                // Create admin transaction
                var transaction = new PaymentTransactionModel
                {
                    ChannelPartnerId = channelPartnerId,
                    TransactionReference = $"admin_upgrade_{DateTime.Now.Ticks}",
                    Amount = amount,
                    TransactionType = "Upgrade",
                    Status = "Success",
                    PaymentMethod = "Admin",
                    TransactionDate = DateTime.Now,
                    CompletedDate = DateTime.Now,
                    PlanName = plan.PlanName,
                    BillingCycle = billingCycle,
                    NetAmount = amount,
                    Description = $"Admin upgrade to {plan.PlanName} plan (scheduled)"
                };

                _context.PaymentTransactions.Add(transaction);
                await _context.SaveChangesAsync();

                // Create scheduled subscription
                var newSubscription = new PartnerSubscriptionModel
                {
                    ChannelPartnerId = channelPartnerId,
                    PlanId = newPlanId,
                    BillingCycle = billingCycle,
                    Amount = amount,
                    StartDate = startDate,
                    EndDate = endDate,
                    Status = "Scheduled",
                    CreatedOn = DateTime.Now
                };

                _context.PartnerSubscriptions.Add(newSubscription);
                await _context.SaveChangesAsync();

                transaction.SubscriptionId = newSubscription.SubscriptionId;
                await _context.SaveChangesAsync();

                var message = existingScheduled.Any() 
                    ? $"Previous scheduled plans replaced. New plan will start on {startDate:dd/MM/yyyy}!"
                    : $"Partner plan scheduled to upgrade on {startDate:dd/MM/yyyy}!";

                return Json(new { success = true, message });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error upgrading partner plan");
                return Json(new { success = false, message = "Failed to upgrade plan. Please try again." });
            }
        }

        // API Endpoints for restrictions
        [HttpGet]
        public async Task<IActionResult> GetAvailablePlans()
        {
            var plans = await _subscriptionService.GetAvailablePlansAsync();
            return Json(plans);
        }

        [HttpGet]
        public async Task<IActionResult> CheckAgentLimit()
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            if (!channelPartnerId.HasValue)
                return Json(new { canAdd = false, message = "Partner context not found" });

            var (canAdd, message) = await _subscriptionService.CanAddAgentAsync(channelPartnerId.Value);
            return Json(new { canAdd, message });
        }

        [HttpGet]
        public async Task<IActionResult> CheckLeadLimit()
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            if (!channelPartnerId.HasValue)
                return Json(new { canAdd = false, message = "Partner context not found" });

            var (canAdd, message) = await _subscriptionService.CanAddLeadAsync(channelPartnerId.Value);
            return Json(new { canAdd, message });
        }

        [HttpGet]
        public async Task<IActionResult> CheckFeatureAccess(string feature)
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            if (!channelPartnerId.HasValue)
                return Json(new { hasAccess = false });

            var hasAccess = await _subscriptionService.HasFeatureAccessAsync(channelPartnerId.Value, feature);
            return Json(new { hasAccess });
        }

        // Export transactions
        [HttpGet]
        public async Task<IActionResult> ExportTransactions(string format = "excel", string? status = null, string? type = null, DateTime? fromDate = null, DateTime? toDate = null)
        {
            var (userId, role, channelPartnerId) = GetCurrentUserContext();
            
            var transactionsQuery = _context.PaymentTransactions
                .Include(t => t.ChannelPartner)
                .Include(t => t.Subscription)
                .ThenInclude(s => s!.Plan)
                .AsQueryable();

            // Filter by partner if not admin
            if (role?.ToLower() == "partner" && channelPartnerId.HasValue)
            {
                transactionsQuery = transactionsQuery.Where(t => t.ChannelPartnerId == channelPartnerId.Value);
            }

            // Apply filters
            if (!string.IsNullOrEmpty(status))
                transactionsQuery = transactionsQuery.Where(t => t.Status == status);

            if (!string.IsNullOrEmpty(type))
                transactionsQuery = transactionsQuery.Where(t => t.TransactionType == type);

            if (fromDate.HasValue)
                transactionsQuery = transactionsQuery.Where(t => t.TransactionDate >= fromDate.Value);

            if (toDate.HasValue)
                transactionsQuery = transactionsQuery.Where(t => t.TransactionDate <= toDate.Value.AddDays(1));

            var transactions = await transactionsQuery
                .OrderByDescending(t => t.TransactionDate)
                .ToListAsync();

            if (format.ToLower() == "csv")
            {
                var csv = GenerateCSV(transactions);
                return File(System.Text.Encoding.UTF8.GetBytes(csv), "text/csv", $"Transactions_{DateTime.Now:yyyy-MM-dd}.csv");
            }

            // For Excel export, you would use a library like EPPlus or ClosedXML
            // For now, returning CSV format
            var csvContent = GenerateCSV(transactions);
            return File(System.Text.Encoding.UTF8.GetBytes(csvContent), "application/vnd.ms-excel", $"Transactions_{DateTime.Now:yyyy-MM-dd}.csv");
        }

        private string GenerateCSV(List<PaymentTransactionModel> transactions)
        {
            var csv = "Date,Partner,Plan,Amount,Type,Status,Payment Method,Transaction ID\n";
            
            foreach (var transaction in transactions)
            {
                csv += $"{transaction.TransactionDate:yyyy-MM-dd HH:mm}," +
                       $"{transaction.ChannelPartner?.CompanyName ?? "N/A"}," +
                       $"{transaction.PlanName ?? "N/A"}," +
                       $"{transaction.Amount}," +
                       $"{transaction.TransactionType}," +
                       $"{transaction.Status}," +
                       $"{transaction.PaymentMethod}," +
                       $"{transaction.TransactionReference}\n";
            }
            
            return csv;
        }

        // Razorpay Webhook Handler
        [HttpPost]
        [Route("/webhook/razorpay")]
        public async Task<IActionResult> RazorpayWebhook()
        {
            try
            {
                var body = await new StreamReader(Request.Body).ReadToEndAsync();
                var signature = Request.Headers["X-Razorpay-Signature"].FirstOrDefault();

                if (string.IsNullOrEmpty(signature) || !_razorpayService.VerifyWebhookSignature(body, signature))
                {
                    _logger.LogWarning("Webhook signature verification failed");
                    return BadRequest("Invalid signature");
                }

                var webhook = System.Text.Json.JsonSerializer.Deserialize<JsonElement>(body);
                var eventType = webhook.GetProperty("event").GetString();
                var eventId = eventType + "_" + DateTime.Now.Ticks; // Basic idempotency key

                // Idempotency check - prevent duplicate webhook processing
                var existingWebhook = await _context.PaymentTransactions
                    .FirstOrDefaultAsync(t => t.WebhookEventId == eventId);
                
                if (existingWebhook != null)
                {
                    _logger.LogInformation($"Webhook event {eventId} already processed, skipping");
                    return Ok(new { status = "already_processed" });
                }

                _logger.LogInformation($"Processing webhook event: {eventType}");

                switch (eventType)
                {
                    case "payment.captured":
                        await HandlePaymentCaptured(webhook, eventId);
                        break;
                    
                    case "payment.failed":
                        await HandlePaymentFailed(webhook, eventId);
                        break;
                    
                    case "payment.authorized":
                        await HandlePaymentAuthorized(webhook, eventId);
                        break;
                    
                    default:
                        _logger.LogInformation($"Unhandled webhook event type: {eventType}");
                        break;
                }

                return Ok(new { status = "processed" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing Razorpay webhook");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        private async Task HandlePaymentCaptured(JsonElement webhook, string eventId)
        {
            var paymentEntity = webhook.GetProperty("payload").GetProperty("payment").GetProperty("entity");
            var paymentId = paymentEntity.GetProperty("id").GetString();
            var orderId = paymentEntity.GetProperty("order_id").GetString();

            _logger.LogInformation($"Payment captured: {paymentId} for order {orderId}");

            var transaction = await _context.PaymentTransactions
                .FirstOrDefaultAsync(t => t.RazorpayOrderId == orderId);
            
            if (transaction != null && (transaction.Status == "Pending" || transaction.Status == "Authorized"))
            {
                transaction.Status = "Success";
                transaction.CompletedDate = DateTime.Now;
                transaction.WebhookEventId = eventId;
                transaction.RazorpayPaymentId = paymentId;
                await _context.SaveChangesAsync();
                
                _logger.LogInformation($"Transaction {transaction.TransactionId} marked as Success");
            }
        }

        private async Task HandlePaymentFailed(JsonElement webhook, string eventId)
        {
            var paymentEntity = webhook.GetProperty("payload").GetProperty("payment").GetProperty("entity");
            var paymentId = paymentEntity.GetProperty("id").GetString();
            var orderId = paymentEntity.GetProperty("order_id").GetString();
            var errorDescription = paymentEntity.TryGetProperty("error_description", out var ed) ? ed.GetString() : "Payment failed";

            _logger.LogWarning($"Payment failed: {paymentId} for order {orderId}, error: {errorDescription}");

            var transaction = await _context.PaymentTransactions
                .FirstOrDefaultAsync(t => t.RazorpayOrderId == orderId);
            
            if (transaction != null)
            {
                transaction.Status = "Failed";
                transaction.CompletedDate = DateTime.Now;
                transaction.WebhookEventId = eventId;
                transaction.RazorpayPaymentId = paymentId;
                transaction.Description += $" | Failed: {errorDescription}";
                await _context.SaveChangesAsync();
            }
        }

        private async Task HandlePaymentAuthorized(JsonElement webhook, string eventId)
        {
            var paymentEntity = webhook.GetProperty("payload").GetProperty("payment").GetProperty("entity");
            var paymentId = paymentEntity.GetProperty("id").GetString();
            var orderId = paymentEntity.GetProperty("order_id").GetString();

            _logger.LogInformation($"Payment authorized: {paymentId} for order {orderId}");

            var transaction = await _context.PaymentTransactions
                .FirstOrDefaultAsync(t => t.RazorpayOrderId == orderId);
            
            if (transaction != null && transaction.Status == "Pending")
            {
                transaction.Status = "Authorized";
                transaction.WebhookEventId = eventId;
                transaction.RazorpayPaymentId = paymentId;
                await _context.SaveChangesAsync();
            }
        }
    }
}